<img src="https://habrastorage.org/files/0e0/67b/a24/0e067ba244494c62b8f4941c4898ba60.jpg"/>

Шаблоны проектирования! Впервые я узнал о них на курсе Software Design, когда учился в магистратуре Академического университета. Мы писали различные программы на Java с использованием шаблонов. С тех пор это словосочетание ассоциируется у меня с чем-то таким ООПшным. Однако, разбираясь с языком Agda, я наткнулся на статью The Power Of Pi, которая рассказывает про шаблоны проектирования в языках с зависимыми типами!

В этом посте я хочу рассказать об одном из этих шаблонов, который называется View. С его помощью можно реализовывать пользовательские правила pattern matching'a. Если вам интересно, что это за шаблон, что такое пользовательский pattern matching, каковы особенности pattern matching'а в языках с зависимыми типами, и вы знакомы с каким-нибудь функциональным языком программирования со статической типизацией (Haskell, Scala, Ocaml, F#) -- добро пожаловать под кат!

<habracut>

<h1>Views и пользовательский pattern matching</h1>
Для начала разберёмся, что такое пользовательский pattern matching. Пусть мы работаем с каким-нибудь списком <i>xs</i> и выполняем на нём pattern matching:
<source lang="scala">
match xs with 
  [] -> ...
  (y : ys) -> ...
</source>
Здесь мы смотрим на <i>xs</i> либо как на пустой список, либо как на список, состоящий из головного элемента и приписанный к нему списка. Но что если мы хотим посмотреть на <i>xs</i>, скажем, как на список, состоящий из конкатенации некоторых двух списков <i>ys</i> и <i>zs</i>? Что-то вроде
<source lang="scala">
match xs with
  [] -> ...
  (ys ++ zs) -> ...
</source>
Иными словами, нам хочется влиять на то, как именно будет представляться структура данных в результате pattern matching'a. Это мы и будем называть пользовательским pattern matching'ом.

По ходу статьи, нашей целью будет реализация пользовательского pattern matching'а для следующей ситуации. Пусть мы работаем с битовыми векторами фиксированной длины. При этом, у нас есть возможность указывать длину вектора прямо в типе. К примеру, запись <i>bits : [32]</i> означает, что <i>bits</i> -- это 32-битный вектор. Мы, в процессе pattern matching'а, хотим иметь возможность различными способами разбивать вектор на равные части, к примеру, так:
<source lang="haskell">
swapAB : [32] -> [32]
swapAB [a b c d] = [b a c d]
</source>
Эта функция принимает на вход 32-битный вектор, разбивает его на 4 части, каждая из которых является 8-битным вектором, и меняет первые два 8-битных слова местами. Она, с тем же успехом, могла разбить его и на 2 части, каждая по 16-бит. Такой функционал может быть полезен при написании криптографического ПО. К примеру, нечто подобное лежит в основе языка Cryptol, который заточен под написание криптографических алгоритмов. Посмотрим, как реализовать такое на Agda.

Общая схема реализации пользовательского pattern matching'а будет такая:
<ol>
<li> Реализовать шаблон View для исходного типа данных
<ol>
<li> Определить тип данных View, конструкторы которого представляют значения исходного типа в нужном нам виде </li>
<li> Написать функцию view, которая по значению исходного типа данных строит значение типа View </li>
</ol> </li>
<li> Использовать pattern matching на результах вызова функции view </li> 
</ol>
Перед тем как разбираться с этими пунктами, определим некоторые базовые типы данных.

<h1>Натуральные числа и вектор в Agda</h1>
Натуральные числа определяются рекурсивно:
<source lang="Haskell">
data Nat : Set where
  Zero : Nat
  Suc  : Nat -> Nat
</source>
При определении типа <i>Nat</i>, мы указываем его тип! Так же как число 3 имеет тип <i>Nat</i>, сам по себе тип <i>Nat</i> имеет тип <i>Set</i>. <i>Set</i> -- это встроенный тип Agda. Однако, понимание, зачем это нужно, нам не пригодится, и можно просто считать, что все типы имеют тип <i>Set</i>, хотя это не правда.
У типа <i>Nat</i> два конструктора: <i>Zero</i>, у которого нет аргументов, и <i>Suc</i> -- конструктор с одним аргументом. Число 3, таким образом, выглядит как <i>(Suc (Suc (Suc Zero)))</i>, то есть что-то вроде (1 + (1 + (1 + 0))). Однако, в Agda есть встроенные литералы, поэтому вместо длинной цепочки <i>Suc</i> можно просто писать 3.

Вектор -- это список фиксированной длины, определяется так:
<source lang="haskell">
data Vec (A : Set) : Nat -> Set where
  [] : Vec A Zero
  _::_ : {n : Nat} -> A -> Vec A n -> Vec A (Suc n)
</source>
Тип <i>Vec</i>, в отличие от <i>Nat</i>, имеет 2 параметра: тип <i>A</i> и значение типа <i>Nat</i>. Благодаря тому, что второй параметр <i>Vec</i> -- это значение, а не тип, <i>Vec</i> является зависимым типом. Тот факт, что параметры отделены друг от друга двоеточием, а не, скажем, символом <i>-></i> -- не совпадение. На самом деле, то, что записано после двоеточия -- это так называемые индексы, а не параметры. Однако, для нас это отличие не будет играть особого значения и мы будем всё называть параметрами.
Первый конструктор строит пустой вектор. В Agda в качестве имён можно использовать разные последовательности символов, поэтому мы можем назвать конструктор<i> []</i>.
Второй конструктор принимает 3 аргумента -- размер вектора <i>n</i>, элемент вектора типа <i>A</i>, вектор размера <i>n</i>, и возвращает вектор размера <i>(n + 1)</i>. Заметим, что для первого аргумента, равно как и для первого параметра самого типа <i>Vec</i>, мы указали не просто тип, но и имя -- <i>n : Nat</i>. Это нужно, потому что мы ссылкаемся на это значение при объявлении третьего аргумента и возвращаемого значения. Кроме того, первый аргумент взят в фигурные скобки. Так в Agda обзначаются неявные аргументы. Дело в том, что значение <i>n</i> можно однозначно восстановить из третьего аргумента конструктора. Действительно, когда мы передаём вектор, мы знаем его размер, он указан в типе. Поэтому, на самом деле, первый аргумент мы можем не передавать -- Agda сама догадается, какой он должен быть. Таким образом, вызов конструктора <i>_::_</i> выглядит либо как <i>_::_ {n} a someVec</i>, либо как <i>_::_ a someVec</i>. Но и это ещё не всё! Символы подчёркивания в имени конструктора, на самом деле, говрят о том, что он является инфиксным. Два явных аргумента можно писать не после имени конструктора, а вместо подчёркиваний, разделяя всё это пробелами. В итоге, вот пример создания вектора:
<source lang="haskell">
v1 : Vec Nat 2
v1 = 1 :: (2 :: [])
</source>
Заметьте, что мы не можем писать так:
<source lang="haskell">
v1 : Vec Nat 3
v1 = 1 :: (2 :: [])
</source>
Конструктор <i>[]</i> создаёт вектор длины 0, первый конструктор <i>::</i> -- вектор длины 1, второй <i>::</i> -- вектор длины 2. Получаем <i>Vec Nat 2</i>, а надо 3. Система вывода типов не даст нам компилировать такой код.

Кроме всего прочего, нам понадобятся некоторые операции над векторами:
<source lang="haskell">
_++_ : forall {A m n} -> Vec A m -> Vec A n -> Vec A (m + n)
take : forall {A m} -> (n : Nat) -> Vec A (n + m) -> Vec A n
drop : forall {A m} -> (n : Nat) -> Vec A (n + m) -> Vec A m
</source>
Это конкатенация векторов, операция "взять первые <i>n</i> элементов" и "выбросить первые <i>n</i> элементов", аналогичные тем, что есть для списка в Haskell. Запись вроде <i>forall {A m n}</i> означает, что, помимо того, что аргументы <i>A</i>, <i>m</i> и <i>n</i> неявные, так мы ещё и не хотим указывать их тип и просим Agda определить его на основе явных аргументов, что опять же происходит очевидным образом.

<h1>Тип битового вектора</h1>
Тип битового вектора, для которого мы будем реализовывать pattern matching, будет выглядеть довольно просто:
<source lang="haskell">
data Bit : Set where
  O : Bit
  I : Bit

Word : Nat -> Set
Word n = Vec Bit n
</source>
<i>Word</i> -- это синоним для <i>Vec Bit</i>, используя его мы можем объявлять 32-битный вектор как <i>bits : Word 32</i>.
Перед тем, как перейти к pattern matching'у, посмотрим на его особенности в присутствии зависимых типов.

<h1>Особенности pattern matching в присутствии завиcимых типов</h1>
Рассмотрим следующий тип данных:
<source lang="haskell">
data _==_ {A : Set} : A -> A -> Set where
  Refl : {x : A} -> x == x
</source>
Тип <i>(x == y)</i> параметризуется двумя конкретными значениями типа <i>A</i> и, как несложно догадаться, представляет утверждение о том, что значения <i>x</i> и <i>y</i> равны. Наличие единственного конструктора <i>Refl</i> гарантирует, что мы не можем создать значения типа <i>(x == y)</i> для разных значений <i>x</i> и <i>y</i>. К примеру:
<source lang="haskell">
eq : (3 == 3)
eq = Refl

notEq : (3 == 4)
notEq = ?
</source>
В первом случае нам нужно сконструировать значение типа <i>(3 == 3)</i> и у нас есть конструктор, который позволяет это сделать -- <i>Refl</i>. Значение же типа <i>(3 == 4)</i> мы сконструировать не можем -- <i>Refl</i> не подходит по типу, а других конструкторов у типа <i>==</i> нет.
Теперь рассмотрим такую функцию:
<source lang="haskell">
f : (x : Nat) -> (y : Nat) -> (x == y) -> Nat
</source>
Как будет выглядеть pattern matching для аргументов этой функции? Очевидно, что для третьего аргумента мы напишем <i>Refl</i>, так как других конструкторов у типа <i>==</i> нет. При этом, мы автоматически узнаём, что первый и второй аргумент -- это одно и то же число! В подобных случаях, в Agda необходимо явно отметить этот факт используя так называемый dot pattern:
<source lang="haskell">
f x .x Refl = x
</source>
Такая запись означает, что второй аргумент (который имеет такое же имя как первый с приписанной точкой) -- это то же самое, что сопоставилось с первым аргументом. Мы не можем написать, скажем, <i>y</i> вместо <i>.x</i>, так как не хотим терять информацию о равенстве, которую получили после сопоставления с <i>Refl</i>.

Вывод отсюда такой: в языках с зависимыми типами, после pattern matching'а на каком-либо аргументе, мы можем получить дополнительную информацию о других аргументах.

<h1>Views</h1>
Перед тем как построить View для нашего типа <i>Word</i>, рассмотрим более простой пример, чтобы понять, чего мы хотим достичь.
Рассмотрим тип списка:
<source lang="haskell">
data List (A : Set) : Set where
  [] : List A
  _::_ : A -> List A -> List A
</source>
Это обычный список, такой же, как в Haskell, он представляется рекурсивно, как "первый элемент и список". Мы хотим получить возможность представить тот же самый список как "список и последний элемент". Заведём для этого тип данных <i>SnocView</i>:
<source lang="haskell">
data SnocView {A : Set} : List A -> Set where
  [] : SnocView []
  _:::_ : (xs : List A) -> (x : A) -> SnocView (xs ++ (x :: []))
</source>
Здесь используется оператор <i>++</i> -- это конкатенация списков, как в Haskell. Пример значения типа <i>SnocView</i>:
<source lang="haskell">
sx : SnocView (1 :: 2 :: 3 :: [])
sx = (1 :: 2 :: []) ::: 3
</source>
Заметьте, что тип <i>SnocView</i> параметризуется списком, для которого строится представление "список и последний элемент".
Теперь напишем функцию <i>snocView</i>, которая для переданного списка строит значение типа <i>SnocView</i>:
<source lang="haskell">
snocView : {A : Set} -> (xs : List A) -> SnocView xs
snocView [] = []
snocView (x :: xs)              with snocView xs
snocView (x :: .[])                | []       = [] ::: x
snocView (x :: .(ys ++ (y :: []))) | ys ::: y = (x :: ys) ::: y
</source>
Здесь много всего, начнём по порядку. Случай с пустым списком очевиден: пустой список даёт тривиальный <i>SnocView</i>. Далее, если список не пуст, мы используем конструкцию with (длинные отступы здесь только для удобства чтения). Это конструкция выполняет примерно те же задачи, что и конструкция case of в Haskell, то есть используется для выполнения pattern matching в теле функции. Образцы, с которыми мы сопоставляем рекурсивный вызов <i>snocView xs</i>, указаны справа от вертикальных чёрточек. Итак, если рекурсивный вызов дал нам тривиальный <i>SnocView</i>, значит список <i>xs</i> был пуст, поэтому <i>SnocView</i> для <i>x :: []</i> -- это <i>[] ::: x</i>. Во втором случае, мы получаем, что <i>SnocView</i> для <i>xs</i> выглядит как <i>ys ::: y</i>, поэтому, чтобы получить <i>SnocView</i> для <i>x :: xs</i> нужно добавить <i>x</i> в голову <i>ys</i>.
Непонятным осталось лишь то, что указано слева от вертикальных чёрточек. Как мы обсуждали ранее, pattern matching в присутствии зависимых типов может давать нам дополнительную информацию о других аргументах функции. В нашем примере, pattern matching на рекурсивном вызове <i>snocView xs</i> даёт нам информацию о том, какое значение имеет список <i>xs</i>. Именно эта информация и указывается с помощью dot patterns слева от вертикальной черты. К примеру, во втором случае, узнав, что <i>snocView xs</i> даёт нам <i>ys ::: y</i>, мы понимаем, что список <i>xs</i> конструируется как конкатенация <i>ys</i> и списка из одного элемента <i>y :: []</i>.

Вот пример использования <i>snocView</i> для написания функции, которая циклически сдвигает переданный список вправо:
<source lang="haskell">
rotateRight : {A : Set} -> List A -> List A
rotateRight xs with snocView xs
rotateRight ._ | [] = []
rotateRight ._ | ys ::: y = y :: ys
</source>
Здесь мы использовали символы подчёркивания. Так можно делать, когда нас не интересует значение, которое должно быть на месте подчёркиваний. Выглядит довольно кратко и красиво! Этот пример, по сути, и показывает, как реализовывть пользовательский pattern matching в языках с зависимыми типами. Посмотрим теперь, как провернуть тоже самое для типа Word!

<h1>SplitView для Word</h1>
Как и в предыдущем примере, нам необходимы 2 вещи: специальный тип данных <i>SplitView</i> и функция <i>splitView</i>, которая будет строить значение <i>SplitView</i> для заданного значения типа <i>Word</i>.
Для начала, нам понадобятся 2 дополнительные функции для работы с типом <i>Vec</i>:
<source lang="haskell">
split : forall {A} -> (n : Nat) -> (m : Nat) -> Vec A (m * n) -> Vec (Vec A n) m
split n Zero [] = []
split n (Suc k) xs = (take n xs) :: (split n k (drop n xs))

concat : forall {A n m } -> Vec (Vec A n) m -> Vec A (m * n)
concat [] = []
concat (xs :: xss) = xs ++ concat xss
</source>
Тип <i>SplitView</i> будет выглядеть так:
<source lang="haskell">
data SplitView {A : Set} : {n : Nat} -> (m : Nat) -> Vec A (m * n) -> Set where
  [_] : forall {m n} -> (xss : Vec (Vec A n) m) -> SplitView m (concat xss)
</source>
Этот тип параметризуется числом <i>m</i> и вектором. <i>m</i> показывает, на сколько частей мы хотим разбить вектор. Именно поэтому длина вектора кратна <i>m</i>. Единственный конструктор позволит нам записывать значения данного типа так:
<source lang="haskell">
[ a :: b :: c :: d :: [] ]
</source>
где a, b, c и d -- векторы длины n.
На очереди функция <i>splitView</i>:
<source lang="haskell">
splitView : {A : Set} -> (n : Nat) -> (m : Nat) -> (xs : Vec A (m * n)) -> SplitView m xs
</source>
Чтобы её реализовать, нужно разбить переданный вектор на <i>m</i> частей, каждая длины <i>n</i>, и передать в конструктор <i>[_]</i>:
<source lang="haskell">
splitView n m xs = [ split n m xs ]
</source>
Однако, такое определение не принимается компилятором. Дело в том, что конструктор <i>[_]</i> возвращает значение типа <i>SplitView m (concat xss)</i>. В нашем случае, <i>xss</i> -- это <i>split n m xs</i>, так что выражение <i>[ split n m xs ]</i> имеет тип <i>SplitView m (concat (split n m xs))</i>. При этом, в сигнатуре функции указано, что она должна вернуть тип <i>SplitView m xs</i>, где <i>xs</i> -- третий аргумент функции. Мы с вами понимаем, что выражения <i>xs</i> и <i>concat (split n m xs)</i> -- это одно и то же, потому что знаем, как устроены функции <i>concat</i> и <i>split</i>. Давайте убедим в этом компилятор.
Для начала, перепишем приведённое выше тело <i>splitView</i> в следующей форме:
<source lang="haskell">
splitView n m xs with [ split n m xs ]
splitView n m xs | v = v
</source>
Это определение не принимается компилятором по тем же причинам, что и предыдущее: <i>v</i> имеет тип <i>SplitView m (concat (split n m xs))</i>, а должно быть <i>SplitView m xs</i>. Продолжим менять определение:
<source lang="haskell">
splitView n m xs with concat (split n m xs) | [ split n m xs ]
splitView n m xs | ys | v = v
</source>
Конструкция with может использоваться для pattern matching'а сразу по нескольким выражениям, которые отделяются друг от друга вертикальными чёрточками. Кроме того, использование with порождает эффект, который называется generalisation. Он проявляется в том, что типы аргументов функции и тип выражения, которое нам необходимо сконструировать, могут меняться в зависимости от того, по каким выражениям мы выполняем pattern matching с помощью with. К примеру, если у нас есть функция
<source lang="haskell">
f x y with e
f x y | p = ...
</source>
то в результате generalisation все вхождения выражения <i>e</i> в типы аргументов <i>x</i> и <i>y</i>, а так же в тип выражения, которое нам нужно сконструировать в теле, заменятся на <i>p</i>. А если у нас есть несколько выражений в with
<source lang="haskell">
f x y with e1 | e2 | e3
f x y | p1 | p2 | p3 = ...
</source>
то, кроме всего прочего, все вхождения <i>e1</i> в <i>p2</i> и <i>p3</i> заменятся на <i>p1</i>, вхождения <i>e2</i> в <i>p3</i> заменятся на <i>p2</i>.
В нашем определении <i>splitView</i>, благодаря добавлению <i>concat (split n m xs)</i> в with тип <i>v</i> изменится с <i>SplitView m (concat (split n m xs))</i> на <i>SplitView m ys</i>. Теперь нам надо доказать, что <i>xs</i> и <i>ys</i> -- это одно и тоже. Чтобы это сделать, нам понадобится следующая функция:
<source lang="haskell">
splitConcatLemma : forall {A} -> (n : Nat) -> (m : Nat) -> (xs : Vec A (m * n)) -> concat (split n m xs) == xs
</source>
По переданному вектору, она конструирует значение знакомого нам типа <i>==</i>, который свидетельствует о равенстве нужных выражений <i>concat (split n m xs)</i> и <i>xs</i>. Используя эту функцию, получим следующую версию <i>splitView</i>:
<source lang="haskell">
splitView n m xs with concat (split n m xs) | [ split n m xs ] | splitConcatLemma n m xs
splitView n m xs | ys | v | eq = v
</source>
Здесь никакие типы не изменились, но <i>eq</i> имеет тип <i>ys == xs</i> благодаря всё тому же эффекту generalisation по первому выражению в with. Теперь у нас есть всё, чтобы заставить функцию работать. Выполним pattern matching на значении <i>eq</i>:
<source lang="haskell">
splitView n m xs with concat (split n m xs) | [ split n m xs ] | splitConcatLemma n m xs
splitView n m xs | .xs | v | Refl = v
</source>
Ура! Теперь всё работает!
Я не привёл здесь определение функции <i>splitConcatLemma</i>. Это не критично для нашего разговора о шаблоне View, кроме того, я уверен, что и так уже загрузил вас! Но, храбрые воины, дочитавшие досюда, конец на горизонте.
Наконец, реализация функции <i>swapAB</i> через пользовательский pattern matching с использованием <i>splitView</i>:
<source lang="haskell">
swapAB : Word 32 -> Word 32
swapAB xs with splitView 8 4 xs
swapAB ._ | [ a :: b :: c :: d :: [] ] = concat (b :: a :: c :: d :: [])
</source>

<h1>Заключение</h1>
После прочтения статьи у вам мог возникнуть вопрос: а нельзя ли такой же подход использовать в языках без зависимых типов? И действительно, всё что мы делали, это задавали тип данных, позволяющий представить исходный тип в нужном нам виде, и писали функцию, которая по входному значению исходного типа конструирует значение целевого.
Отличие использования такого подхода в языках без зависимых типов заключается в том, что мы теряем связь с исходным значением. К примеру, тип <i>SnocView</i> зависит от значения списка, для которого мы его строим, то есть связь между исходным значением и View сохраняется на уровне типов. За счёт этого, при выполнении pattern matching на значениях <i>SnocView xs</i> мы узнаём информацию о том, как именно выглядит исходный список <i>xs</i>. Без зависимых типов получать такую информацию не получится.
Второе отличие, вытекающее из первого, заключается в том, что без зависимых типов, функция, которая строит View, будет слишком общей. К примеру, функция <i>snocView</i> имеет тип:
<source lang="haskell">
snocView : {A : Set} -> (xs : List A) -> SnocView xs
</source>
Из него ясно, что тело функции не может быть совершенно произвольным -- оно ограниченно тем фактом, что <i>SnocView</i> зависит от <i>xs</i>. Если бы у нас не было зависимых типов, то эта функция могла бы иметь тип
<source lang="haskell">
snocView : List A -> SnocView
</source>
и, скажем, просто возвращать пустой список на любом входе, что делает её достаточно бесполезной.

Поэтому, закончу свой пост словами, с которых начинается статья The Power Of Pi: dependent types matter!

<i>Ссылки:</i>
<a href="http://cs.ru.nl/~wouters/Publications/ThePowerOfPi.pdf">Nicolas Oury, Wouter Swierstra "The Power Of Pi"</a>
<a href="http://agda.readthedocs.org/en/latest/language/with-abstraction.html">Документация по with</a>